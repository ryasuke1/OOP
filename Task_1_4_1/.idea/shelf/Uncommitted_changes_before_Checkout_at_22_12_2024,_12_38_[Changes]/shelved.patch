Index: ../Task_1_3_1/src/test/java/ru/nsu/khubanov/SubstringFinderTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ru.nsu.khubanov;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\n\n\npublic class SubstringFinderTest {\n\n    @Test\n    public void testSmallFileSingleMatch() throws IOException {\n        createTestFile(\"test1.txt\", \"абракадабра\");\n        List<Integer> result = SubstringFinder.find(\"test1.txt\", \"рак\");\n        assertEquals(List.of(2), result);\n    }\n\n    @Test\n    public void testSmallFileNoMatch() throws IOException {\n        createTestFile(\"test2.txt\", \"абракадабра\");\n        List<Integer> result = SubstringFinder.find(\"test2.txt\", \"xyz\");\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testSmallFileOverlappingMatches() throws IOException {\n        createTestFile(\"test3.txt\", \"aaaaa\");\n        List<Integer> result = SubstringFinder.find(\"test3.txt\", \"aaa\");\n        assertEquals(List.of(0, 1, 2), result);\n    }\n\n    @Test\n    public void testLargeFileWithMatches() throws IOException {\n        createTestFile(\"test4.txt\", \"абракадабра\".repeat(1000));\n        List<Integer> result = SubstringFinder.find(\"test4.txt\", \"бра\");\n        assertEquals(2000, result.size());\n    }\n\n    @Test\n    public void testLargeFileNoMatches() throws IOException {\n        createTestFile(\"test5.txt\", \"абракадабра\".repeat(1000));\n        List<Integer> result = SubstringFinder.find(\"test5.txt\", \"xyz\");\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testEmptyFile() throws IOException {\n        createTestFile(\"test6.txt\", \"\");\n        List<Integer> result = SubstringFinder.find(\"test6.txt\", \"бра\");\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testSubstringLongerThanFileContent() throws IOException {\n        createTestFile(\"test7.txt\", \"абра\");\n        List<Integer> result = SubstringFinder.find(\"test7.txt\", \"абракадабра\");\n        assertTrue(result.isEmpty());\n    }\n\n    private void createTestFile(String fileName, String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), StandardCharsets.UTF_8))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    public void testChineseCharactersSingleMatch() throws IOException {\n        createTestFile(\"test_chinese_1.txt\", \"你好，世界！你好！\");\n        List<Integer> result = SubstringFinder.find(\"test_chinese_1.txt\", \"你好\");\n        assertEquals(List.of(0, 6), result);\n    }\n\n    @Test\n    public void testEmojisSingleMatch() throws IOException {\n        createTestFile(\"test_emoji_1.txt\", \"\uD83D\uDE00\uD83D\uDE03\uD83D\uDE04\uD83D\uDE01\uD83D\uDE06\uD83D\uDE05\uD83D\uDE02\uD83D\uDE0A\uD83D\uDE07\");\n        List<Integer> result = SubstringFinder.find(\"test_emoji_1.txt\", \"\uD83D\uDE05\");\n        assertEquals(List.of(11), result); // Индекс символа \"\uD83D\uDE05\" (начиная с 0)\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Task_1_3_1/src/test/java/ru/nsu/khubanov/SubstringFinderTest.java b/../Task_1_3_1/src/test/java/ru/nsu/khubanov/SubstringFinderTest.java
--- a/../Task_1_3_1/src/test/java/ru/nsu/khubanov/SubstringFinderTest.java	(revision 3c11582b97fc67460da6055c30c538cadd4bf7ca)
+++ b/../Task_1_3_1/src/test/java/ru/nsu/khubanov/SubstringFinderTest.java	(date 1734845685242)
@@ -34,9 +34,9 @@
 
     @Test
     public void testLargeFileWithMatches() throws IOException {
-        createTestFile("test4.txt", "абракадабра".repeat(1000));
+        createTestFile("test4.txt", "абракадабра".repeat(1000000));
         List<Integer> result = SubstringFinder.find("test4.txt", "бра");
-        assertEquals(2000, result.size());
+        assertEquals(2000000, result.size());
     }
 
     @Test
Index: ../Task_1_2_2/src/main/java/ru/nsu/khubanov/HashTable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ru.nsu.khubanov;\nimport java.util.*;\n\npublic class HashTable<K, V> implements Iterable<Entry<K, V>> {\n    private static final int INITIAL_CAPACITY = 16; // Начальная емкость\n    private static final float LOAD_FACTOR = 0.75f; // Коэффициент загрузки\n\n    private int size; // Текущее количество элементов\n    private int capacity; // Текущая емкость массива\n    private int modCount; // Счетчик изменений для итератора\n    private LinkedList<Entry<K, V>>[] table; // Массив списков для хранения пар ключ-значение\n\n    @SuppressWarnings(\"unchecked\")\n    public HashTable() {\n        this.capacity = INITIAL_CAPACITY;\n        this.table = new LinkedList[capacity];\n        this.size = 0;\n        this.modCount = 0;\n    }\n\n    public void put(K key, V value) {\n        int index = getIndex(key);\n        if (table[index] == null) {\n            table[index] = new LinkedList<>();\n        }\n        for (Entry<K, V> entry : table[index]) {\n            if (Objects.equals(entry.key, key)) {\n                entry.value = value;\n                return;\n            }\n        }\n        table[index].add(new Entry<>(key, value));\n        size++;\n        modCount++;\n        if (size > capacity * LOAD_FACTOR) {\n            resize();\n        }\n    }\n\n    public V get(K key) {\n        int index = getIndex(key);\n        if (table[index] != null) {\n            for (Entry<K, V> entry : table[index]) {\n                if (Objects.equals(entry.key, key)) {\n                    return entry.value;\n                }\n            }\n        }\n        return null;\n    }\n\n    public void update(K key, V value) {\n        int index = getIndex(key);\n        for (Entry<K, V> entry : table[index]) {\n            if (Objects.equals(entry.key, key)) {\n                entry.value = value;\n                return;\n            }\n        }\n    }\n\n    public boolean containsKey(K key) {\n        int index = getIndex(key);\n        if (table[index] != null) {\n            for (Entry<K, V> entry : table[index]) {\n                if (Objects.equals(entry.key, key)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public void remove(K key) {\n        int index = getIndex(key);\n        if (table[index] != null) {\n            Iterator<Entry<K, V>> iterator = table[index].iterator();\n            while (iterator.hasNext()) {\n                Entry<K, V> entry = iterator.next();\n                if (Objects.equals(entry.key, key)) {\n                    iterator.remove();\n                    size--;\n                    modCount++;\n                    return;\n                }\n            }\n        }\n    }\n\n    public Set<Entry<K, V>> entrySet() {\n        Set<Entry<K, V>> entrySet = new HashSet<>();\n        for (LinkedList<Entry<K, V>> bucket : table) {\n            if (bucket != null) {\n                entrySet.addAll(bucket); // Добавляем все элементы бакета\n            }\n        }\n        return entrySet;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        HashTable<?, ?> that = (HashTable<?, ?>) o;\n        // Сравниваем множества пар ключ-значение\n        return Objects.equals(this.entrySet(), that.entrySet());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(entrySet()); // Вычисляем хэш-код на основе entrySet\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(\"{\");\n        for (Entry<K, V> entry : entrySet()) { // Используем entrySet\n            sb.append(entry.key).append(\"=\").append(entry.value).append(\", \");\n        }\n        if (sb.length() > 1) {\n            sb.setLength(sb.length() - 2); // Удаляем последнюю запятую и пробел\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    private int getIndex(K key) {\n        return key == null ? 0 : Math.abs(key.hashCode() % capacity);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void resize() {\n        capacity *= 2;\n        LinkedList<Entry<K, V>>[] oldTable = table;\n        table = new LinkedList[capacity];\n        size = 0;\n        for (LinkedList<Entry<K, V>> bucket : oldTable) {\n            if (bucket != null) {\n                for (Entry<K, V> entry : bucket) {\n                    put(entry.key, entry.value);\n                }\n            }\n        }\n    }\n    @Override\n    public Iterator<Entry<K, V>> iterator() {\n        return new EntryIterator();\n    }\n\n\n    private class EntryIterator implements Iterator<Entry<K, V>> {\n        private final int expectedModCount = modCount; // Ожидаемое значение modCount для проверки изменений\n        private int currentIndex = 0; // Текущий индекс массива table\n        private Iterator<Entry<K, V>> bucketIterator = table[currentIndex] == null ? null : table[currentIndex].iterator(); // Итератор текущего бакета\n\n        @Override\n        public boolean hasNext() {\n            // Проверяем текущий бакет\n            if (bucketIterator != null && bucketIterator.hasNext()) {\n                return true;\n            }\n            // Переходим к следующему бакету\n            while (++currentIndex < table.length) {\n                if (table[currentIndex] != null) {\n                    bucketIterator = table[currentIndex].iterator();\n                    if (bucketIterator.hasNext()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Entry<K, V> next() {\n            // Проверяем, не изменилась ли таблица\n            if (modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            // Если нет следующего элемента, выбрасываем исключение\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            // Получаем следующий элемент из текущего бакета\n            return bucketIterator.next();\n        }\n    }\n\n\n    public int size() {\n        return size;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Task_1_2_2/src/main/java/ru/nsu/khubanov/HashTable.java b/../Task_1_2_2/src/main/java/ru/nsu/khubanov/HashTable.java
--- a/../Task_1_2_2/src/main/java/ru/nsu/khubanov/HashTable.java	(revision 3c11582b97fc67460da6055c30c538cadd4bf7ca)
+++ b/../Task_1_2_2/src/main/java/ru/nsu/khubanov/HashTable.java	(date 1734844443212)
@@ -51,6 +51,9 @@
 
     public void update(K key, V value) {
         int index = getIndex(key);
+        if (table[index] == null) {
+            table[index] = new LinkedList<>();
+        }
         for (Entry<K, V> entry : table[index]) {
             if (Objects.equals(entry.key, key)) {
                 entry.value = value;
